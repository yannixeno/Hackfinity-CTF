## Cryptosystem

> Breaking a Weak Key

![The challenge](https://github.com/user-attachments/assets/baf43972-ba1e-46ec-8dfb-5ea8d5d9baa3)

---

### RSA schooling

RSA usually works like this:

Two big secret prime numbers are picked: p and q

Multiply them to get n = p * q

Choose a public exponent e (usually 65537)

The secret key d is calculated using some math with p, q, and e

Messages are encrypted like this: cipher = message^e mod n

To decrypt: message = cipher^d mod n

Normally, you can't figure out p and q just from n — it would take forever with large numbers.

---

### The Flaw

Instead of picking two totally random primes, the challenge script did this:

```bash
p = getPrime(1024)
q = primo(p)
```
That means q is just the next prime after p. Normally in RSA, p and q are far apart, but here they’re right next to each other. That makes factoring n way easier than usual.

---

### Further Math Headaches

A python script was created and the flag was spit out.

```bash
from Crypto.Util.number import isPrime, inverse, long_to_bytes
from math import isqrt

n = 15956250162063169819282947443743274370048643274416742655348817823973383829364700573954709256391245826513107784713930378963551647706777479778285473302665664446406061485616884195924631582130633137574953293367927991283669562895956699807156958071540818023122362163066253240925121801013767660074748021238790391454429710804497432783852601549399523002968004989537717283440868312648042676103745061431799927120153523260328285953425136675794192604406865878795209326998767174918642599709728617452705492122243853548109914399185369813289827342294084203933615645390728890698153490318636544474714700796569746488209438597446475170891
c = 3591116664311986976882299385598135447435246460706500887241769555088416359682787844532414943573794993699976035504884662834956846849863199643104254423886040489307177240200877443325036469020737734735252009890203860703565467027494906178455257487560902599823364571072627673274663460167258994444999732164163413069705603918912918029341906731249618390560631294516460072060282096338188363218018310558256333502075481132593474784272529318141983016684762611853350058135420177436511646593703541994904632405891675848987355444490338162636360806437862679321612136147437578799696630631933277767263530526354532898655937702383789647510
e = 65537

sqrt_n = isqrt(n)  
p = sqrt_n
while True:
    if n % p == 0 and isPrime(p):  
        q = n // p
        if isPrime(q):  
            break
    p -= 1  

phi = (p - 1) * (q - 1)  
d = inverse(e, phi)  

m = pow(c, d, n)  
flag = long_to_bytes(m).decode()  

print(f"Decrypted Flag: {flag}")
```

THM{Just_s0m3_small_amount_of_RSA!}

